# coding: utf-8
"""
gather_data.py

Usage:
    python gather_data.py RAW_DATA_DIR OUTPUT_DIR

RAW_DATA_DIR must have a specific structure, like the one generated by
aveta-bastion's movedata.pl (github.com/yati-sagade/aveta-bastion)

An example:

    $ ls ~/aveta-training-data-final
    /home/ys/aveta-training-data-final/
    ├── cochlea
    │   ├── 0
    │   │   ├── commands.txt
    │   │   ├── original-name
    │   │   ├── sync.txt
    │   │   └── video.avi
    │   └── 1
    │       ├── commands.txt
    │       ├── original-name
    │       ├── sync.txt
    │       └── video.avi
    └── simple
        ├── 0
        │   ├── commands.txt
        │   ├── original-name
        │   ├── sync.txt
        │   └── video.avi
        ├── 1
        │   ├── commands.txt
        │   ├── original-name
        │   ├── sync.txt
        │   └── video.avi
        ├── 2
        │   ├── commands.txt
        │   ├── original-name
        │   ├── sync.txt
        │   └── video.avi
        ├── 3
        │   ├── commands.txt
        │   ├── original-name
        │   ├── sync.txt
        │   └── video.avi
        └── 4
            ├── commands.txt
            ├── original-name
            ├── sync.txt
            └── video.avi

OUTPUT
------

The output directory contains all images from all drives in the input directory.
There's also a file called speeds.txt, which contains lines of the following
form:

    <filename>,<left-speed1>,<right-speed1>,<left-speed2>,<right-speed2>

The first pair of speeds is the speeds before the user control command and
the second pair is the speeds after the command.

"""
import re
import cv2
import sys
import argparse
import os
import shutil
import tarfile
from collections import defaultdict
from itertools import izip, chain
try:
    import cPickle as pkl
except ImportError:
    import pickle as pkl


import numpy as np

from common import (command_mapping, command_rev_mapping,
                    command_readable_mapping)


def main(input_dir, output_dir, verbose, frame_size=None,
         grayscale=False, compress=False, augment=True):

    if not os.path.exists(input_dir) or not os.path.isdir(input_dir):
        print("{} does not name a directory.".format(input_dir))
        return 1

    if os.path.exists(output_dir):
        shutil.rmtree(output_dir)
    os.makedirs(output_dir)

    mappings = []
    file_num = 0 # output image files start with 0.jpg
    for tagname in os.listdir(input_dir):
        if tagname.startswith("."):
            continue
        tagdir = os.path.join(input_dir, tagname)
        if not os.path.isdir(tagdir):
            continue
        file_num = _process_tagdir(tagdir, output_dir, frame_size, grayscale,
                                   augment=augment, file_num=file_num)
    if compress:
        _compress_dir(output_dir, output_dir+".tar.gz")

    return 0

def _compress_dir(dirname, output_path, compression="gz"):
    try:
        os.unlink(output_path)
    except OSError:
        pass
    mode = "w:" + compression
    with tarfile.open(output_path, mode) as tar:
        tar.add(dirname, arcname=os.path.basename(dirname))


def _process_tagdir(dirname, output_dir, frame_size, grayscale, file_num=0,
                    augment=True):
    """Process a single tagdir."""
    mappings = []
    for idx in os.listdir(dirname):
        datadir = os.path.join(dirname, idx)
        if not idx.isdigit() or not os.path.isdir(datadir):
            continue
        vidfile, syncfile, cmdfile = [
            os.path.join(datadir, fname)
            for fname in ("video.avi", "sync.txt", "commands.txt")
        ]
        file_num = _process_files(
            vidfile, syncfile, cmdfile, output_dir, frame_size, grayscale,
            augment=augment, file_num=file_num
        )
    return file_num


def _process_files(video_filename, sync_filename, cmd_filename, output_dir,
                   frame_size, grayscale, augment=True, file_num=0):
    """Process a single set of files datafiles. `output_dir` is populated with
    actual stuff here. Return one plus the last file number written to."""
    sync = _read_file(sync_filename, value_mapper=lambda vs: (int(vs[0]),))
    cmds = _read_file(cmd_filename)
    frames = izip(weighted_iter(sync), _video_frame_iter(video_filename,
                                                         grayscale=grayscale))
    speedfile = os.path.join(output_dir, "speeds.txt")

    def _write_data(speedfile_out, frame, lspeed, rspeed, lspeed_after,
                    rspeed_after, file_num):
        imfile = "{}.jpg".format(file_num)
        speedfile_out.write("{},{},{},{},{}\n".format(
            imfile, lspeed, rspeed, lspeed_after, rspeed_after
        ))
        cv2.imwrite(os.path.join(output_dir, imfile), frame)

    with open(speedfile, "a+b") as out:
        for dataline in _cmd_frame_iter(frames, iter(cmds)):
            (frame, cmd, lspeed, rspeed, lspeed_after, rspeed_after) = dataline

            if frame_size is not None:
                out_frame = cv2.resize(frame, frame_size,
                                       interpolation=cv2.INTER_AREA)
            else:
                out_frame = frame

            _write_data(out, out_frame, lspeed, rspeed, lspeed_after,
                        rspeed_after, file_num)
            file_num += 1

            if augment:
                _write_data(
                    out, cv2.flip(out_frame, 1), rspeed, lspeed, rspeed_after,
                    lspeed_after, file_num
                )
                file_num += 1

    return file_num


def _video_frame_iter(video_filename, grayscale=False):
    cap = cv2.VideoCapture(video_filename)
    if cap is None:
        raise Exception("Could not read video {}".format(video_filename))
    while cap.isOpened():
        flag, frame = cap.read()
        if not flag:
            break
        out = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) if grayscale else frame
        yield out


def _cmd_frame_iter(frames, cmds):
    """Match timestamped frames and commands.

    Args:
        frames: An iterator yielding (str, numpy.ndarray), or timestamped
        video frames.

        cmds: An iterator yielding timestamped commands of the form

            (<timestamp>, <command-char>, <lspeed-before>, <rspeed-before>,
             <lspeed-after>, <rspeed-after>)

    Returns:
        An iterator yielding (numpy.array, str), for a video frame and the
        (best-effort) matching command.

    NOTE: Command can be None when there was no command seen for a given frame.
    """
    # NOTE 1: This assignment of "no command" to certain frames is incorrect,
    # strictly speaking, since frames are classified "no command" only when
    # the command stream for a given second has been exhausted.
    def _next_frame(it):
        t, x = next(it)
        return (int(float(t)), x)

    def _next_cmd(it):
        t, c, l0, r0, l1, r1 = next(it)
        return (int(float(t)), c, float(l0), float(r0), float(l1), float(r1))

    ret = []
    read_frame, read_cmd = True, True
    while True:
        if read_frame:
            frame_time, frame = _next_frame(frames)
        if read_cmd:
            (cmd_time, cmd, left_speed, right_speed, left_speed_after,
             right_speed_after)  = _next_cmd(cmds)

        if cmd_time < frame_time:
            # Drop this command
            read_cmd, read_frame = True, False
            continue
        elif cmd_time > frame_time:
            read_cmd, read_frame = False, True
            # No command; see `NOTE 1` above.
            yield frame, None, left_speed, right_speed, left_speed, right_speed
        else:
            read_frame, read_cmd = True, True
            yield (frame, cmd, left_speed, right_speed, left_speed_after,
                   right_speed_after)

    for _, frame in frames:
        yield frame, None, left_speed, right_speed, left_speed, right_speed


def _read_file(filename, value_mapper=lambda x: x):
    """Read a file with comma separated <key,val1,val2...> lines.

    Returns a list of (key, val1, val2..) tuples sorted by the key ascending. If
    `value_mapper` is given, it is passed a tuple of length `num_fields-1`
    containing the `num_fields-1` values on line.
    """
    retmap = {}
    with open(filename) as fp:
        for line in fp:
            split_line = line.strip().split(",")
            key = split_line[0]
            vals = tuple(split_line[1:])
            # For command files, there *might* be multiple commands per tick, but
            # we'll just pick the last one in the file.
            retmap[key] = value_mapper(vals)

    for key, vals in sorted(retmap.items(), key=lambda t: t[0]):
        yield tuple(chain([key], vals))


def weighted_iter(buckets):
    """Given a sequence of (key, count) items, return an iterator yielding
    keys in agreement with the counts."""
    for key, count in buckets:
        for _ in xrange(count):
            yield key


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("input_dir", help="Input directory")
    parser.add_argument("output_dir", help="Output directory")
    parser.add_argument("--frame_size", type=str, default=None)
    parser.add_argument("--verbose", action="store_true",
                        help="Give verbose output")
    parser.add_argument("--grayscale", action="store_true",
                        help="Store grayscale images in the output. "
                             "Default is to store colour images")
    parser.add_argument("--compress", action="store_true",
                        help="Also generate a compressed tarball of the "
                             "output directory.")
    parser.add_argument("--augment", action="store_true",
                        help="Augment training data by flipping speeds and images")
    args = parser.parse_args()
    return args


if __name__ == "__main__":
    args = parse_args()
    sz = None
    if args.frame_size is not None:
        try:
            frame_w, frame_h = map(int, args.frame_size.split("x"))
        except:
            print("--frame_size must be of the form 'MxN', where M, N are "
                  "both integers.")
            sys.exit(1)
        sz = (frame_w, frame_h)
    try:
        shutil.rmtree(args.output_dir)
    except OSError:
        pass
    sys.exit(main(args.input_dir, args.output_dir, args.verbose,
                  frame_size=sz,
                  grayscale=args.grayscale,
                  compress=args.compress,
                  augment=args.augment))
