# coding: utf-8
"""
gather_data.py

Usage:
    python gather_data.py RAW_DATA_DIR OUTPUT_DIR

RAW_DATA_DIR must have a specific structure, like the one generated by
aveta-bastion's movedata.pl (github.com/yati-sagade/aveta-bastion)

An example:
    
    $ ls ~/aveta-training-data-final
    /home/ys/aveta-training-data-final/
    ├── cochlea
    │   ├── 0
    │   │   ├── commands.txt
    │   │   ├── original-name
    │   │   ├── sync.txt
    │   │   └── video.avi
    │   └── 1
    │       ├── commands.txt
    │       ├── original-name
    │       ├── sync.txt
    │       └── video.avi
    └── simple
        ├── 0
        │   ├── commands.txt
        │   ├── original-name
        │   ├── sync.txt
        │   └── video.avi
        ├── 1
        │   ├── commands.txt
        │   ├── original-name
        │   ├── sync.txt
        │   └── video.avi
        ├── 2
        │   ├── commands.txt
        │   ├── original-name
        │   ├── sync.txt
        │   └── video.avi
        ├── 3
        │   ├── commands.txt
        │   ├── original-name
        │   ├── sync.txt
        │   └── video.avi
        └── 4
            ├── commands.txt
            ├── original-name
            ├── sync.txt
            └── video.avi

This script collects all video and command files -- using the sync files to match
commands with frames -- and writes the final training data into OUTPUT_DIR. The
video frames are converted to grayscale before writing.

Two files are written, images.pkl and labels.pkl. The former contains a numpy
array with one flattened video frame per row, and the latter contains a numpy
array of integers, each representing user input at the corresponding frame in
the images array.

Command codes:
    
    0: No input
    1: Forward
    2: Left
    3: Back
    4: Right
    5: Straighten course
    6: Halt

"""
import cv2
import sys
import argparse
import os
from collections import defaultdict

def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("input_dir", help="Input directory")
    parser.add_argument("output_dir", help="Output directory")
    args = parser.parse_args()
    return args

def main(input_dir, output_dir):
    if not os.path.exists(input_dir):
        print("There is no directory at {}".format(input_dir))
        return 1
    
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)


def build_mapping(video_filename, sync_filename, cmd_filename):
    """Given paths to the video, sync and command files, return two items:
       a numpy array with flattened frames of the video, one per row, and
       another numpy array with the user command codes found in the
       corresponding frame.
    """
    cap = cv2.VideoCapture(video_filename)
    if cap is None:
        raise Exception("Could not read video {}".format(video_filename))
    sync = _read_file(sync_filename)
    cmd = _read_file(cmd_filename)
    while cap.isOpened():
        flag, frame = cap.read()
        if not flag:
            break

def _read_file(filename):
    ret = {}
    with open(filename) as fp:
        for line in fp:
            timestamp, num_frames = line.strip().split(",")
        # For command files, there *might* be multiple commands per tick, but
        # we'll just pick the last one in the file.
        ret[timestamp] = int(num_frames)
    return ret

def weighted_iter(buckets):
    """Given a sequence of (key, count) items, return an iterator that
    yields keys in accordance with the counts
    """
    for key, count in buckets:
        for _ in xrange(count):
            yield key

def bucket_zip(src, buckets):
    """When buckets is a sequence of (key,count) pairs, and src an iterator,
    return an iterator yielding pairs of the form (k, s), where k is a key
    from `buckets` and `s` is an element from `src`. In the resulting iterator,
    the key k appears c times, where c is the count associated with it in
    `buckets`. Iteration stops when either of the two inputs are exhausted.
    """
    src = iter(src)
    for key in weighted_iter(buckets):
        yield key, next(src)


if __name__ == "__main__":
    args = parse_args()
    sys.exit(main(args.input_dir, args.output_dir))



