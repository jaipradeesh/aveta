# coding: utf-8
"""
gather_data.py

Usage:
    python gather_data.py RAW_DATA_DIR OUTPUT_DIR

RAW_DATA_DIR must have a specific structure, like the one generated by
aveta-bastion's movedata.pl (github.com/yati-sagade/aveta-bastion)

An example:

    $ ls ~/aveta-training-data-final
    /home/ys/aveta-training-data-final/
    ├── cochlea
    │   ├── 0
    │   │   ├── commands.txt
    │   │   ├── original-name
    │   │   ├── sync.txt
    │   │   └── video.avi
    │   └── 1
    │       ├── commands.txt
    │       ├── original-name
    │       ├── sync.txt
    │       └── video.avi
    └── simple
        ├── 0
        │   ├── commands.txt
        │   ├── original-name
        │   ├── sync.txt
        │   └── video.avi
        ├── 1
        │   ├── commands.txt
        │   ├── original-name
        │   ├── sync.txt
        │   └── video.avi
        ├── 2
        │   ├── commands.txt
        │   ├── original-name
        │   ├── sync.txt
        │   └── video.avi
        ├── 3
        │   ├── commands.txt
        │   ├── original-name
        │   ├── sync.txt
        │   └── video.avi
        └── 4
            ├── commands.txt
            ├── original-name
            ├── sync.txt
            └── video.avi

This script collects all video and command files -- using the sync files to match
commands with frames -- and writes the final training data into OUTPUT_DIR. The
video frames are converted to grayscale before writing.

Two files are written, images.pkl and labels.pkl. The former contains a numpy
array with one flattened video frame per row, and the latter contains a numpy
array of integers, each representing user input at the corresponding frame in
the images array.

Command codes:

    0: No input
    1: Forward
    2: Left
    3: Back
    4: Right
    5: Straighten course
    6: Halt

"""
import cv2
import sys
import argparse
import os
from collections import defaultdict
from itertools import izip
try:
    import cPickle as pkl
except ImportError:
    import pickle as pkl


import numpy as np


command_mapping = {None: 0, "u": 1, "l": 2, "d": 3, "r": 4, "s": 5, "h": 6}


command_rev_mapping = {v: k for k, v in command_mapping.items()}


command_readable_mapping = [
    "NOP",
    "FORWARD",
    "LEFT",
    "DOWN",
    "RIGHT",
    "STRAIGHTEN",
    "HALT"
]


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("input_dir", help="Input directory")
    parser.add_argument("output_dir", help="Output directory")
    parser.add_argument("--verbose", action="store_true", help="Give verbose output")
    args = parser.parse_args()
    return args


def main(input_dir, output_dir, verbose):
    if not os.path.exists(input_dir) or not os.path.isdir(input_dir):
        print("{} does not name a directory.".format(input_dir))
        return 1

    if os.path.exists(output_dir) and not os.path.isdir(output_dir):
        print("{} does not name a directory.".format(output_dir))
        return 1
    elif not os.path.exists(output_dir):
        os.makedirs(output_dir)

    mappings = []
    for tagname in os.listdir(input_dir):
        tagdir = os.path.join(input_dir, tagname)
        if not os.path.isdir(tagdir):
            continue
        mappings.append(_process_tagdir(tagdir))

    mapping = _merge_mappings(*mappings)
    if verbose:
        print("Mapping built, size: {} bytes".format(sys.getsizeof(mapping)))

    outfile = os.path.join(output_dir, "mapping.pkl")
    with open(outfile, "wb") as out:
        pkl.dump(mapping, out)

    return 0


def _process_tagdir(dirname):
    """Build and return the mapping for a single tagdir."""
    mappings = []
    for idx in os.listdir(dirname):
        datadir = os.path.join(dirname, idx)
        if not idx.isdigit() or not os.path.isdir(datadir):
            continue
        vidfile, syncfile, cmdfile = [
            os.path.join(datadir, fname)
            for fname in ("video.avi", "sync.txt", "commands.txt")
        ]
        mappings.append(build_mapping(vidfile, syncfile, cmdfile))
    return _merge_mappings(*mappings)


def _merge_mappings(*mappings):
    """Return a merger of multiple mappings."""
    if not len(mappings):
        return None

    all_sizes = {mapping["frame_size"] for mapping in mappings}
    if len(all_sizes) != 1:
        raise ValueError("Different frame_size mappings cannot be merged.")

    all_frames = [mapping["frames"] for mapping in mappings]
    all_commands = [mapping["commands"] for mapping in mappings]

    img_size = all_sizes.pop()
    return {
        "frames": np.vstack(all_frames),
        "commands": np.hstack(all_commands),
        "frame_size": img_size,
    }


def display_mapping(mapping, img_size, random_order=False):
    """Display mapping in an interactive window.

    Open a window with a frame from the `mapping` overlaid with the command
    corresponding to the frame in the mapping. If `random_order` is False,
    walk sequentially through the mapping, else select randomly.
    """
    mapping = list(mapping)
    def _itermapping():
        i = 0
        while i < len(mapping):
            if random_order:
                yield np.random.choice(mapping)
            else:
                yield mapping[i]
            i += 1
    win_name = "mappings"
    win = cv2.namedWindow(win_name, cv2.WINDOW_NORMAL)
    for frame, cmd in _itermapping():
        read_cmd = command_readable_mapping[command_mapping[cmd]]
        msg = "Cmd: {}".format(read_cmd)
        img = frame.reshape(img_size)
        cv2.putText(img, msg, (50, 50), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 0))
        cv2.imshow(win_name, frame)
        if cv2.waitKey(0) & ord("q") == ord("q"):
            break
    cv2.destroyAllWindows()


def build_mapping(video_filename, sync_filename, cmd_filename):
    """Build a map from video frames to corresponding user commands.

    Given paths to the video, sync and command files, return a dict containing
    the frames, commands and the frame size.
    """

    sync = _read_file(sync_filename, value_mapper=int)
    cmds = _read_file(cmd_filename)
    frames = izip(weighted_iter(sync), _video_frame_iter(video_filename))

    img_size = None
    ret_frames, ret_commands = [], []
    for frame, command in _cmd_frame_iter(frames, iter(cmds)):
        if img_size is None:
            img_size = frame.shape
        elif img_size != frame.shape:
            raise ValueError("frames of different sizes encountered.")
        ret_frames.append(frame.reshape(-1))
        ret_commands.append(command_mapping[command])

    return {"frames": np.array(ret_frames),
            "commands": np.array(ret_commands),
            "frame_size": img_size}


def _video_frame_iter(video_filename):
    cap = cv2.VideoCapture(video_filename)
    if cap is None:
        raise Exception("Could not read video {}".format(video_filename))
    while cap.isOpened():
        flag, frame = cap.read()
        if not flag:
            break
        yield cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)


def _cmd_frame_iter(frames, cmds):
    """Match timestamped frames and commands.

    Args:
        frames: An iterator yielding (str, numpy.ndarray), or timestamped
        video frames.

        cmds: An iterator yielding (str, str), or timestamped commands.

    Returns:
        An iterator yielding (numpy.array, str), for a video frame and the
        (best-effort) matching command.

    NOTE: Command can be None when there was no command seen for a given frame.
    """
    # NOTE: This assignment of "no command" to certain frames is incorrect,
    # strictly speaking, since frames are classified "no command" only when
    # the command stream for a given second has been exhausted.
    def _next(it):
        t, x = next(it)
        return (int(float(t)), x)

    ret = []
    read_frame, read_cmd = True, True
    while True:
        if read_frame:
            frame_time, frame = _next(frames)
        if read_cmd:
            cmd_time, cmd = _next(cmds)

        if cmd_time < frame_time:
            # Drop this command
            read_cmd, read_frame = True, False
            continue
        elif cmd_time > frame_time:
            read_cmd, read_frame = False, True
            yield frame, None # No command; see note above.
        else:
            read_frame, read_cmd = True, True
            yield frame, cmd

    for _, frame in frames:
        yield frame, None


def _read_file(filename, value_mapper=lambda x: x):
    """Read a file with comma separated <key,value> lines.

    Returns a list of (key, value) tuples sorted by the key ascending. If
    `value_mapper` is given, it is applied to the value read from the file.
    """
    ret = {}
    with open(filename) as fp:
        for line in fp:
            key, value = line.strip().split(",")
            # For command files, there *might* be multiple commands per tick, but
            # we'll just pick the last one in the file.
            ret[key] = value_mapper(value)
    return sorted(ret.items(), key=lambda t: t[0])


def weighted_iter(buckets):
    """Given a sequence of (key, count) items, return an iterator yielding keys in agreement with the counts."""
    for key, count in buckets:
        for _ in xrange(count):
            yield key


if __name__ == "__main__":
    args = parse_args()
    sys.exit(main(args.input_dir, args.output_dir, args.verbose))
